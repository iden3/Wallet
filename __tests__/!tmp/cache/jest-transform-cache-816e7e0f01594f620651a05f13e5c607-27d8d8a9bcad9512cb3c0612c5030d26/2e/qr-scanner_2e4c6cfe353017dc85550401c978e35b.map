{"version":3,"sources":["qr-scanner.js"],"names":["LIVE_STREAM","ENDED_STREAM","QRScanner","props","canvasElement","videoElement","state","srcObject","getVideoTracks","stop","readyState","HAVE_ENOUGH_DATA","setState","window","requestAnimationFrame","_handleStreamTick","bind","canvas","getContext","drawImage","width","height","imageData","getImageData","code","data","inversionAttempts","console","log","closeCamera","scanImage","PureComponent"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,WAAW,GAAG,MAApB;AACA,IAAMC,YAAY,GAAG,OAArB;AAEA;;;;;;;IAMMC,S;;;;;AAMJ,qBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACjB,mFAAMA,KAAN;;AADiB,oFALX;AACNC,MAAAA,aAAa,EAAE,EADT;AAENC,MAAAA,YAAY,EAAE;AAFR,KAKW;;AAAA,0FASL,YAAM;AAClB,YAAKC,KAAL,CAAWD,YAAX,CAAwBE,SAAxB,CAAkCC,cAAlC,GAAmD,CAAnD,EAAsDC,IAAtD;AACD,KAXkB;;AAAA,wFAoBP,UAACJ,YAAD,EAAeD,aAAf,EAAiC;AAC3C,UAAIC,YAAY,CAACK,UAAb,KAA4BL,YAAY,CAACM,gBAA7C,EAA+D;AAC7D,cAAKC,QAAL,CAAc;AACZR,UAAAA,aAAa,EAAbA,aADY;AAEZC,UAAAA,YAAY,EAAZA;AAFY,SAAd,EAGG;AAAA,iBAAMQ,MAAM,CAACC,qBAAP,CAA6B,YAAM;AAC1C,kBAAKC,iBAAL;AACD,WAFQ,CAAN;AAAA,SAHH;AAMD;AACF,KA7BkB;;AAEjB,UAAKA,iBAAL,GAAyB,MAAKA,iBAAL,CAAuBC,IAAvB,uDAAzB;AAFiB;AAGlB;AAED;;;;;;;;;AA0BA;;;;;wCAKoB;AAClB;AACA;AACA,UAAI,KAAKV,KAAL,CAAWD,YAAX,CAAwBE,SAAxB,CAAkCC,cAAlC,GAAmD,CAAnD,EAAsDE,UAAtD,KAAqEV,WAAzE,EAAsF;AACpF,YAAMiB,MAAM,GAAG,KAAKX,KAAL,CAAWF,aAAX,CAAyBc,UAAzB,CAAoC,IAApC,CAAf,CADoF,CAGpF;;AACAD,QAAAA,MAAM,CAACE,SAAP,CAAiB,KAAKb,KAAL,CAAWD,YAA5B,EAA0C,CAA1C,EAA6C,CAA7C,EAAgD,KAAKC,KAAL,CAAWF,aAAX,CAAyBgB,KAAzE,EAAgF,KAAKd,KAAL,CAAWF,aAAX,CAAyBiB,MAAzG;AACA,YAAMC,SAAS,GAAGL,MAAM,CAACM,YAAP,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,KAAKjB,KAAL,CAAWF,aAAX,CAAyBgB,KAAnD,EAA0D,KAAKd,KAAL,CAAWF,aAAX,CAAyBiB,MAAnF,CAAlB,CALoF,CAMpF;AACA;AACA;;AACA,YAAMG,IAAI,GAAG,mBAAKF,SAAS,CAACG,IAAf,EAAqBH,SAAS,CAACF,KAA/B,EAAsCE,SAAS,CAACD,MAAhD,EAAwD;AACnEK,UAAAA,iBAAiB,EAAE;AADgD,SAAxD,CAAb,CAToF,CAapF;;AACA,YAAIF,IAAJ,EAAU;AACRG,UAAAA,OAAO,CAACC,GAAR,CAAY,wBAAZ,EAAsCJ,IAAI,CAACC,IAA3C;AACA,eAAKI,WAAL;AACD,SAjBmF,CAmBpF;;;AACAhB,QAAAA,MAAM,CAACC,qBAAP,CAA6B,KAAKC,iBAAlC;AACD,OAxBiB,CA0BlB;;;AACA,UAAI,KAAKT,KAAL,CAAWD,YAAX,CAAwBE,SAAxB,CAAkCC,cAAlC,GAAmD,CAAnD,EAAsDE,UAAtD,KAAqET,YAAzE,EAAuF;AACrF,aAAK4B,WAAL;AACD;AACF;;;6BAEQ;AACP,aACE,6BAAC,uBAAD;AACE,QAAA,OAAO,EAAE,KAAKA,WADhB;AAEE,QAAA,2BAA2B,EAAE,KAAKC;AAFpC,QADF;AAKD;;;;;;;;;;;EAhFqBC,oB;;eAmFT7B,S;;;;;;;;;;;;;;0BA5FTF,W;0BACAC,Y;0BAQAC,S","sourcesContent":["import React, { PureComponent } from 'react';\nimport jsQR from 'jsqr';\nimport { Camera } from 'base_components';\n\nconst LIVE_STREAM = 'live';\nconst ENDED_STREAM = 'ended';\n\n/**\n * Class  that uses jsqr library to scan a QR and retrieve the data.\n * Uses the camera component to get the stream and find the QR.\n * ScanImage is a function triggered for each tick of the video stream\n * for parsing the image and look for a QR code\n */\nclass QRScanner extends PureComponent {\n  state = {\n    canvasElement: {},\n    videoElement: {},\n  };\n\n  constructor(props) {\n    super(props);\n    this._handleStreamTick = this._handleStreamTick.bind(this);\n  }\n\n  /**\n   * Access to the video stream and stop them, removing them from the event loop\n   * @param {object} stream of the video\n   */\n  closeCamera = () => {\n    this.state.videoElement.srcObject.getVideoTracks()[0].stop();\n  };\n\n  /**\n   * Parse the current tick of the stream video to check if there is\n   * any QR code and retrieve the data inside\n   * @param {node || number} videoElement HTML Element with the video streaming\n   * @param {node} canvasElement HTML Canvas Element with a hidden canvas element from which get the info of\n   * the video stream and manipulate it\n   */\n  scanImage = (videoElement, canvasElement) => {\n    if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {\n      this.setState({\n        canvasElement,\n        videoElement,\n      }, () => window.requestAnimationFrame(() => {\n        this._handleStreamTick();\n      }));\n    }\n  };\n\n  /**\n   * Handle each tick of the stream to check if there is any QR shown\n   * to capture the data\n   * @private\n   */\n  _handleStreamTick() {\n    // It is needed do this check, otherwise a lot of animation frames are added to event loop\n    // and even we unmount the component the are many frames to deal with in the stack\n    if (this.state.videoElement.srcObject.getVideoTracks()[0].readyState === LIVE_STREAM) {\n      const canvas = this.state.canvasElement.getContext('2d');\n\n      // write current video stream tick in the canvas for parsing it and check if there is any QR code\n      canvas.drawImage(this.state.videoElement, 0, 0, this.state.canvasElement.width, this.state.canvasElement.height);\n      const imageData = canvas.getImageData(0, 0, this.state.canvasElement.width, this.state.canvasElement.height);\n      // Should jsQR attempt to invert the image to find QR codes with white modules\n      // on black backgrounds instead of the black modules on white background. Set it to dontInvert\n      // for performance. Please, visit https://github.com/cozmo/jsQR for more info\n      const code = jsQR(imageData.data, imageData.width, imageData.height, {\n        inversionAttempts: 'dontInvert',\n      });\n\n      // check if QR code found\n      if (code) {\n        console.log('=====> QR CODE FOUND: ', code.data);\n        this.closeCamera();\n      }\n\n      // move forward next frame\n      window.requestAnimationFrame(this._handleStreamTick);\n    }\n\n    // check if stream finished (when camera is closed or component unmount)\n    if (this.state.videoElement.srcObject.getVideoTracks()[0].readyState === ENDED_STREAM) {\n      this.closeCamera();\n    }\n  }\n\n  render() {\n    return (\n      <Camera\n        onClose={this.closeCamera}\n        handleRequestAnimationFrame={this.scanImage} />\n    );\n  }\n}\n\nexport default QRScanner;\n"]}