{"version":3,"sources":["utils.js"],"names":["areEqualArrays","arr1","arr2","length","firstArrayLength","i","constructor","Array","Object","areEqualFunctions","fn1","fn2","toString","areEqualObjects","obj1","obj2","keys","p","Function","createUniqueAlphanumericId","radix","Math","random","mergeDeep","target","sources","source","shift","isObject","key","assign","sortArray","pivot","pop","Error","left","right","forEach","element","_element","_pivot","push","concat","pad","digit","toCamelCase","str","String","replace","g","toUpperCase","capitalizeFirstLetter","charAt","slice"],"mappings":"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","sourcesContent":["/**\n * Check if two arrays are equal recursively: in length and in values,\n * even if they contain other arrays, objects...\n * @param {any[]} arr1 first array to compare\n * @param {any[]} arr2 second array to compare\n * @returns {boolean}\n */\nexport const areEqualArrays = function (arr1, arr2) {\n  // if one of the arrays is a falsy value, return\n  if (!arr1 || !arr2) {\n    return false;\n  }\n\n  // compare lengths - can save a lot of time\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  const firstArrayLength = arr1.length;\n\n  for (let i = 0; i < firstArrayLength; i++) {\n    // first check if are same type\n    if (arr1[i].constructor !== arr2[i].constructor) { // Check if are they are of the same type\n      return false;\n    }\n\n    if (arr1[i] instanceof Array && arr2[i] instanceof Array) { // Check if we have nested arrays\n      // recurse into the nested arrays\n      if (!this.areEqualArrays(arr1[i], arr2[i])) {\n        return false;\n      }\n    } else if (arr1[i] instanceof Object && arr2[i] instanceof Object) { // Check if both are objects\n      // deep comparison between objects\n      if (!this.areEqualArrays(arr1[i], arr2[i])) {\n        return false;\n      }\n    } else if (arr1[i] !== arr2[i]) {\n      // Warning - two different object instances will never be equal: {x:20} != {x:20}\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Check if two function are the same\n * @param {Function} fn1 first function to compare\n * @param {Function} fn2 second function to compare\n * @returns {boolean}\n */\n\nexport const areEqualFunctions = function (fn1, fn2) {\n  return fn1 === fn2 || fn1.toString() === fn2.toString();\n};\n\n/**\n * Check if two objects are equal recursively: in length and in values,\n * even if they contain other object, arrays...\n * @param {Object} obj1 first object to compare\n * @param {Object} obj2 second object to compare\n * @returns {boolean}\n */\nexport const areEqualObjects = function (obj1, obj2) {\n  // check if one of them is null or undefined return false\n  if (!obj1 || !obj2) {\n    return false;\n  }\n\n  // check they have same length\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n    return false;\n  }\n\n  let p;\n\n  for (p in obj1) {\n    if (typeof (obj2[p]) === 'undefined') { return false; }\n  }\n\n  for (p in obj1) {\n    if (obj1[p]) {\n      switch (obj1[p].constructor) {\n        case Object:\n          if (!this.areEqualObjects(obj1[p], obj2[p])) { return false; } break;\n        case Function:\n          if (typeof (obj2[p]) === 'undefined'\n            || (p !== 'equals' && obj1[p].toString() !== obj2[p].toString())) {\n            return false;\n          }\n          break;\n        default:\n          if (obj1[p] !== obj2[p]) { return false; }\n      }\n    } else if (obj2[p]) {\n      return false;\n    }\n  }\n\n  for (p in obj2) {\n    if (typeof (obj1[p]) === 'undefined') { return false; }\n  }\n\n  return true;\n};\n\n/**\n * Generate a random an unique key in base 36 such as \"0.94rz766tytb\"\n * @returns {string} with the generated alphanumeric key\n */\nexport const createUniqueAlphanumericId = function (radix = 36) {\n  return Math.random().toString(radix);\n};\n\n/**\n * Performs a deep merge of two objects\n * @param {Object} target object\n * @param {Object} sources the other object\n */\nexport const mergeDeep = function (target, ...sources) {\n  if (!sources.length) return target;\n  const source = sources.shift();\n\n  if (this.isObject(target) && this.isObject(source)) {\n    for (const key in source) {\n      if (this.isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} });\n        this.mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    }\n  }\n\n  return this.mergeDeep(target, ...sources);\n};\n\n/**\n * Sort an array. Uses QuickSort algorithm: average time complexity is O(log n) (worst: O(n^2)) and\n * space complexity (worst) is O(log(n))\n * @param {any[]} target array to sort\n * @param {string} key if we have an array of objects and we want to sort by certain key\n * @returns {*}\n */\nexport const sortArray = function (target, key = '') {\n  // if only we have one element, finish\n  if (target.length < 2) return target;\n\n  // Take the pivot to compare in each iteration\n  // in order to place the element on the right (bigger)\n  // or in the left (lower)\n  const pivot = target.pop();\n\n  // check if pivot is an Object and then we have sent a valid key to compare to sort\n  if (pivot.constructor === Object) {\n    if (!key || !pivot[key]) {\n      throw new Error(`==> sortArray(): no key sent or pivot (${pivot}) has not any key ${key}`);\n    }\n  }\n\n  // sub arrays to sort regarding the pivot\n  const left = [];\n  const right = [];\n\n  // iterate over all the array\n  target.forEach((element) => {\n    const _element = element.constructor === Object ? element[key] : element;\n    const _pivot = pivot.constructor === Object ? pivot[key] : pivot;\n    // check if pivot and current element they are same type\n    if (_pivot.constructor !== _element.constructor) {\n      throw new Error('==> sortArray(): not all elements are of the same type. Can\\'t be sorted');\n    }\n\n    // check if current element is an object and it contains the sent key for sorting\n    if ((_element.constructor === Object) && !_element[key]) {\n      throw new Error(`==> sortArray(): there is an object in the array (${_element}) \n                      that does not contain the key ${key}`);\n    }\n    // if current element is lower than the pivot,\n    // put it in the left array\n    if (_element < _pivot) {\n      left.push(_element);\n    } else if (_element > _pivot) {\n      right.push(_element);\n    } else {\n      // if current element and pivot are the same\n      left.push(_element);\n    }\n  });\n\n  // create a new array, ordering left and right part with a recursive call to\n  // this function of sorting. The pivot remains between boths arrays\n  return [].concat(sortArray(left), pivot, sortArray(right));\n};\n\n/**\n * Pad a digit of one cypher returning a string with a 2 chars. I.e. 1 to \"01\"\n * @param {number} digit of one cypher\n * @returns {string} with two chars, the first one is a \"0\"\n */\nexport const pad = function (digit) {\n  return (digit < 10) ? `0${digit.toString()}` : digit.toString();\n};\n\n/**\n * Convert a string to camelCase format. i.e. from Mykey to myKey\n * @param {string} str string to convert to camel Case\n * @returns {string} string in camelCase format\n */\nexport const toCamelCase = function (str) {\n  if (!str || str.constructor !== String) {\n    throw new Error('[util] toCamelCase() expects a string');\n  }\n\n  return str.replace(/-([a-z])/g, g => g[1].toUpperCase());\n};\n\nexport const capitalizeFirstLetter = function (str) {\n  return str\n    ? str.charAt(0).toUpperCase() + str.slice(1)\n    : str;\n};\n"]}